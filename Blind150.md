# Blind 150 Algorithm Questions

The Blind 150 is a curated list of essential coding interview questions that covers the most important algorithmic concepts. This list is an extension of the original Blind 75, providing comprehensive coverage for technical interviews.

## Array Problems

### Easy
1. **Two Sum** - Find two numbers that add up to target
2. **Best Time to Buy and Sell Stock** - Maximum profit from buying and selling once
3. **Contains Duplicate** - Check if array contains duplicates
4. **Product of Array Except Self** - Calculate product of all elements except current
5. **Maximum Subarray** - Find contiguous subarray with largest sum
6. **Maximum Product Subarray** - Find contiguous subarray with largest product
7. **Find Minimum in Rotated Sorted Array** - Find minimum in rotated array
8. **Search in Rotated Sorted Array** - Search target in rotated sorted array
9. **3Sum** - Find all unique triplets that sum to zero
10. **Container With Most Water** - Find two lines that contain most water

### Medium
11. **Search in Rotated Sorted Array II** - Search in rotated array with duplicates
12. **Find Peak Element** - Find peak element in array
13. **Search a 2D Matrix** - Search target in 2D matrix
14. **Spiral Matrix** - Return spiral order of matrix elements
15. **Rotate Image** - Rotate n×n 2D matrix by 90 degrees
16. **Set Matrix Zeroes** - Set entire row and column to zero if element is zero
17. **Longest Consecutive Sequence** - Find length of longest consecutive sequence

## String Problems

### Easy
18. **Valid Anagram** - Check if two strings are anagrams
19. **Valid Parentheses** - Check if parentheses are valid
20. **Valid Palindrome** - Check if string is palindrome
21. **Longest Substring Without Repeating Characters** - Find longest substring without repeating characters
22. **Longest Repeating Character Replacement** - Longest substring with same character after k replacements
23. **Minimum Window Substring** - Find minimum window containing all characters
24. **Group Anagrams** - Group strings that are anagrams
25. **Longest Palindromic Substring** - Find longest palindromic substring
26. **Palindromic Substrings** - Count palindromic substrings

### Medium
27. **Encode and Decode Strings** - Design encode/decode functions
28. **Word Break** - Check if string can be segmented
29. **Word Break II** - Return all possible sentences
30. **Regular Expression Matching** - Implement regex matching
31. **Wildcard Matching** - Implement wildcard pattern matching

## Linked List Problems

### Easy
32. **Reverse Linked List** - Reverse a linked list
33. **Linked List Cycle** - Detect cycle in linked list
34. **Merge Two Sorted Lists** - Merge two sorted linked lists
35. **Remove Nth Node From End of List** - Remove nth node from end
36. **Reorder List** - Reorder list in specific pattern

### Medium
37. **Add Two Numbers** - Add two numbers represented as linked lists
38. **Copy List with Random Pointer** - Deep copy list with random pointers
39. **Merge k Sorted Lists** - Merge k sorted linked lists
40. **Reverse Nodes in k-Group** - Reverse nodes in groups of k
41. **Swap Nodes in Pairs** - Swap every two adjacent nodes

## Binary Tree Problems

### Easy
42. **Maximum Depth of Binary Tree** - Find maximum depth
43. **Same Tree** - Check if two trees are same
44. **Invert Binary Tree** - Invert/flip binary tree
45. **Binary Tree Maximum Path Sum** - Find maximum path sum
46. **Binary Tree Level Order Traversal** - Level order traversal
47. **Serialize and Deserialize Binary Tree** - Serialize/deserialize tree
48. **Subtree of Another Tree** - Check if tree is subtree
49. **Construct Binary Tree from Preorder and Inorder Traversal** - Build tree from traversals
50. **Validate Binary Search Tree** - Check if tree is valid BST
51. **Kth Smallest Element in a BST** - Find kth smallest in BST
52. **Lowest Common Ancestor of a Binary Search Tree** - Find LCA in BST
53. **Implement Trie (Prefix Tree)** - Implement trie data structure
54. **Add and Search Word** - Design add and search words data structure
55. **Word Search II** - Find all words in board

### Medium
56. **Binary Tree Right Side View** - Right side view of tree
57. **Count Good Nodes in Binary Tree** - Count good nodes
58. **Path Sum III** - Number of paths with given sum
59. **Diameter of Binary Tree** - Find diameter of tree
60. **Balanced Binary Tree** - Check if tree is balanced

## Dynamic Programming

### Easy
61. **Climbing Stairs** - Number of ways to climb stairs
62. **Coin Change** - Minimum coins for amount
63. **Longest Increasing Subsequence** - Length of LIS
64. **Longest Common Subsequence** - Length of LCS
65. **Word Break** - Check if string can be segmented
66. **Combination Sum IV** - Number of combinations
67. **House Robber** - Maximum money without robbing adjacent
68. **House Robber II** - Houses arranged in circle
69. **Decode Ways** - Number of ways to decode string
70. **Unique Paths** - Number of unique paths in grid
71. **Jump Game** - Check if can reach last index

### Medium
72. **Edit Distance** - Minimum operations to convert strings
73. **Partition Equal Subset Sum** - Check if can partition into equal sum
74. **Target Sum** - Number of ways to reach target
75. **Palindrome Partitioning** - Partition string into palindromes
76. **Maximum Product Subarray** - Maximum product of contiguous subarray
77. **Best Time to Buy and Sell Stock with Cooldown** - Stock with cooldown
78. **Best Time to Buy and Sell Stock with Transaction Fee** - Stock with fee

## Graph Problems

### Medium
79. **Number of Islands** - Count number of islands
80. **Clone Graph** - Clone undirected graph
81. **Pacific Atlantic Water Flow** - Water flow to both oceans
82. **Course Schedule** - Check if can finish all courses
83. **Course Schedule II** - Return course order
84. **Graph Valid Tree** - Check if edges form valid tree
85. **Number of Connected Components in Undirected Graph** - Count components
86. **Alien Dictionary** - Find order of characters
87. **Word Ladder** - Transform one word to another
88. **Minimum Height Trees** - Find minimum height trees
89. **Network Delay Time** - Time for signal to reach all nodes

### Hard
90. **Cheapest Flights Within K Stops** - Find cheapest flight path

## Heap/Priority Queue

### Easy
91. **Kth Largest Element in an Array** - Find kth largest element
92. **Top K Frequent Elements** - Find k most frequent elements
93. **Find Median from Data Stream** - Design median finder

### Medium
94. **Meeting Rooms** - Check if person can attend all meetings
95. **Meeting Rooms II** - Minimum meeting rooms needed
96. **Task Scheduler** - Minimum time to execute tasks
97. **Design Twitter** - Design simplified Twitter

## Sliding Window

### Medium
98. **Sliding Window Maximum** - Maximum in each sliding window
99. **Minimum Window Substring** - Minimum window containing all characters
100. **Longest Substring Without Repeating Characters** - Longest unique substring
101. **Longest Repeating Character Replacement** - Longest substring after k changes
102. **Permutation in String** - Check if permutation exists
103. **Find All Anagrams in a String** - Find all anagram start indices

## Backtracking

### Medium
104. **Combination Sum** - Find all combinations that sum to target
105. **Combination Sum II** - Combinations with each number used once
106. **Permutations** - Generate all permutations
107. **Permutations II** - Permutations with duplicates
108. **Subsets** - Generate all subsets
109. **Subsets II** - Subsets with duplicates
110. **Word Search** - Find word in board
111. **Palindrome Partitioning** - Partition into palindromes
112. **Letter Combinations of a Phone Number** - Generate letter combinations
113. **Generate Parentheses** - Generate valid parentheses

## Two Pointers

### Easy
114. **Valid Palindrome** - Check if string is palindrome
115. **Two Sum II - Input Array Is Sorted** - Two sum in sorted array
116. **3Sum** - Find triplets that sum to zero
117. **3Sum Closest** - Find triplet closest to target
118. **4Sum** - Find quadruplets that sum to target
119. **Remove Duplicates from Sorted Array** - Remove duplicates in-place
120. **Container With Most Water** - Maximum water container

## Binary Search

### Medium
121. **Search in Rotated Sorted Array** - Search in rotated array
122. **Find Minimum in Rotated Sorted Array** - Find minimum in rotated array
123. **Search a 2D Matrix** - Search in 2D matrix
124. **Koko Eating Bananas** - Minimum eating speed
125. **Find Peak Element** - Find peak in array
126. **Search Insert Position** - Find insert position
127. **First Bad Version** - Find first bad version

## Bit Manipulation

### Easy
128. **Single Number** - Find single number in array
129. **Number of 1 Bits** - Count set bits
130. **Counting Bits** - Count bits for numbers 0 to n
131. **Reverse Bits** - Reverse bits of integer
132. **Missing Number** - Find missing number
133. **Sum of Two Integers** - Add without using + operator

## Stack

### Easy
134. **Valid Parentheses** - Check valid parentheses
135. **Min Stack** - Design stack with min operation
136. **Evaluate Reverse Polish Notation** - Evaluate RPN expression
137. **Generate Parentheses** - Generate valid parentheses
138. **Daily Temperatures** - Find next warmer temperature
139. **Car Fleet** - Calculate car fleets

## Math & Geometry

### Medium
140. **Rotate Image** - Rotate matrix 90 degrees
141. **Spiral Matrix** - Traverse matrix spirally
142. **Set Matrix Zeroes** - Set rows/columns to zero
143. **Happy Number** - Check if number is happy
144. **Plus One** - Add one to large integer
145. **Pow(x, n)** - Implement power function

## Advanced Problems

### Hard
146. **Trapping Rain Water** - Calculate trapped rainwater
147. **Median of Two Sorted Arrays** - Find median of two arrays
148. **Merge k Sorted Lists** - Merge k sorted linked lists
149. **Largest Rectangle in Histogram** - Find largest rectangle area
150. **Sliding Window Maximum** - Maximum in sliding window

---

## Study Tips

1. **Start with Easy Problems**: Begin with the fundamentals and gradually work your way up
2. **Understand Patterns**: Focus on recognizing common patterns rather than memorizing solutions
3. **Practice Regularly**: Consistency is key - practice a few problems daily
4. **Time Yourself**: Practice under time constraints to simulate interview conditions
5. **Optimize Solutions**: Always try to improve time and space complexity
6. **Explain Your Approach**: Practice explaining your solution out loud

## Problem-Solving Framework

1. **Understand the Problem**: Read carefully and ask clarifying questions
2. **Think of Examples**: Work through examples to understand the pattern
3. **Choose Data Structure**: Select appropriate data structures
4. **Write Pseudocode**: Plan your approach before coding
5. **Implement Solution**: Write clean, readable code
6. **Test Your Solution**: Verify with examples and edge cases
7. **Optimize**: Look for ways to improve efficiency

## Time Complexity Goals

- **Arrays/Strings**: O(n) or O(n log n)
- **Trees**: O(h) where h is height, ideally O(log n)
- **Graphs**: O(V + E) for most traversals
- **Dynamic Programming**: Often O(n²) or O(n)
- **Sorting**: O(n log n) for comparison-based sorts

Remember: The key to success is consistent practice and understanding the underlying patterns!
